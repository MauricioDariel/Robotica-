{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Modelado Completo de Robot SCARA\n",
    "## Examen Parcial - Rob√≥tica\n",
    "### Torbell√≠n Sanchez Mauricio Dariel\n",
    "\n",
    "---\n",
    "\n",
    "## Diagrama de Flujo del Proceso de Modelado\n",
    "\n",
    "```mermaid\n",
    "graph TD\n",
    "    A[Cinem√°tica de Posici√≥n] --> B[Transformaciones DH]\n",
    "    B --> C[Modelo Directo]\n",
    "    B --> D[Modelo Inverso]\n",
    "    C --> E[Cinem√°tica de Velocidades]\n",
    "    D --> E\n",
    "    E --> F[Jacobiano]\n",
    "    F --> G[Singularidades]\n",
    "    E --> H[Cinem√°tica de Aceleraciones]\n",
    "    H --> I[Derivada Jacobiano]\n",
    "    I --> J[Din√°mica Euler-Lagrange]\n",
    "    J --> K[Modelo Din√°mico]\n",
    "    K --> L[Validaci√≥n]\n",
    "    L --> M[Aplicaciones Control]\n",
    "```\n",
    "\n",
    "---"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 1. Introducci√≥n\n",
    "\n",
    "### 1.1 Contexto y Relevancia\n",
    "La automatizaci√≥n industrial moderna depende de arquitecturas rob√≥ticas que combinan velocidad, precisi√≥n y repetibilidad..."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 2.1 Definici√≥n de funci√≥n de transformaci√≥n homog√©nea\n",
    "import sympy as sp\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "from IPython.display import display, Math\n",
    "\n",
    "# Definir variables simb√≥licas\n",
    "x_i_j, y_i_j, z_i_j, gi_j, bi_j, ai_j = sp.symbols('x_i_j y_i_j z_i_j gamma_i_j beta_i_j alpha_i_j')\n",
    "\n",
    "# Matriz de transformaci√≥n homog√©nea\n",
    "def Tij(x, y, z, gamma, beta, alpha):\n",
    "    return sp.Matrix([\n",
    "        [sp.cos(alpha)*sp.cos(beta), sp.cos(alpha)*sp.sin(beta)*sp.sin(gamma)-sp.sin(alpha)*sp.cos(gamma), sp.sin(alpha)*sp.sin(gamma)+sp.cos(alpha)*sp.sin(beta)*sp.cos(gamma), x],\n",
    "        [sp.sin(alpha)*sp.cos(beta), sp.cos(alpha)*sp.cos(gamma)+sp.sin(alpha)*sp.sin(beta)*sp.sin(gamma), sp.sin(alpha)*sp.sin(beta)*sp.cos(gamma)-sp.cos(alpha)*sp.sin(gamma), y],\n",
    "        [-sp.sin(beta), sp.cos(beta)*sp.sin(gamma), sp.cos(beta)*sp.cos(gamma), z],\n",
    "        [0, 0, 0, 1]\n",
    "    ])\n",
    "\n",
    "print(\"Funci√≥n Tij definida correctamente\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 2.2 Par√°metros Denavit-Hartenberg del Robot SCARA"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Definir variables simb√≥licas para el robot SCARA\n",
    "x_O_1, y_O_1, theta_O_1, L_1, theta_1_2, L_2, theta_2_3, L_3 = sp.symbols('x_O_1 y_O_1 theta_O_1 L_1 theta_1_2 L_2 theta_2_3 L_3')\n",
    "\n",
    "# Transformaciones entre sistemas de referencia\n",
    "T_O_1 = Tij(x_O_1, y_O_1, 0, 0, 0, theta_O_1)\n",
    "T_1_2 = Tij(L_1, 0, 0, 0, 0, theta_1_2)\n",
    "T_2_3 = Tij(L_2, 0, 0, 0, 0, theta_2_3)\n",
    "T_3_P = Tij(L_3, 0, 0, 0, 0, 0)\n",
    "\n",
    "# Transformaci√≥n total\n",
    "T_O_P = T_O_1 * T_1_2 * T_2_3 * T_3_P\n",
    "T_O_P_simplified = sp.simplify(T_O_P)\n",
    "\n",
    "print(\"Transformaci√≥n homog√©nea total T_O_P:\")\n",
    "display(Math(sp.latex(T_O_P_simplified)))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 3. Validaci√≥n Num√©rica del Modelo"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 5.3 Validaci√≥n Num√©rica del Modelo Din√°mico\n",
    "print(\"=== VALIDACI√ìN NUM√âRICA DEL MODELO DIN√ÅMICO ===\")\n",
    "\n",
    "# Par√°metros num√©ricos de prueba\n",
    "params = {\n",
    "    'm_1': 2.0, 'm_2': 1.5, 'm_3': 0.8,\n",
    "    'L_1': 0.3, 'L_2': 0.25, 'L_3': 0.15,\n",
    "    'x_1_C1': 0.15, 'x_2_C2': 0.125, 'x_3_C3': 0.075,\n",
    "    'g': 9.81\n",
    "}\n",
    "\n",
    "# Configuraci√≥n de prueba\n",
    "config_test = [sp.pi/4, -sp.pi/6, sp.pi/3]  # theta_O_1, theta_1_2, theta_2_3\n",
    "vel_test = [0.5, -0.3, 0.2]  # velocidades articulares\n",
    "acel_test = [0.1, 0.05, -0.1]  # aceleraciones articulares\n",
    "torques_test = [1.0, 0.5, 0.2]  # torques aplicados\n",
    "\n",
    "print(f\"Configuraci√≥n de prueba: {[float(c) for c in config_test]} rad\")\n",
    "print(f\"Velocidades: {vel_test} rad/s\")\n",
    "print(f\"Aceleraciones: {acel_test} rad/s¬≤\")\n",
    "print(f\"Torques aplicados: {torques_test} N¬∑m\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 4. An√°lisis de Singularidades"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 3.5.1 An√°lisis Profundo de Singularidades\n",
    "print(\"=== AN√ÅLISIS DE SINGULARIDADES ===\")\n",
    "\n",
    "# Configuraciones singulares t√≠picas del SCARA\n",
    "singular_configs = [\n",
    "    [0, 0, 0],           # Codo completamente extendido\n",
    "    [0, sp.pi, 0],       # Codo completamente contra√≠do\n",
    "    [sp.pi/2, 0, 0],     # Posici√≥n l√≠mite de trabajo\n",
    "    [sp.pi/4, sp.pi/2, 0] # Configuraci√≥n potencialmente singular\n",
    "]\n",
    "\n",
    "print(\"\\nAn√°lisis del determinante del Jacobiano:\")\n",
    "for i, config in enumerate(singular_configs, 1):\n",
    "    # Evaluar Jacobiano en configuraci√≥n\n",
    "    J_eval = J_theta.subs([\n",
    "        (theta_O_1, config[0]),\n",
    "        (theta_1_2, config[1]), \n",
    "        (theta_2_3, config[2])\n",
    "    ])\n",
    "    \n",
    "    det_J = J_eval.det()\n",
    "    det_value = float(det_J) if det_J.is_number else det_J\n",
    "    \n",
    "    print(f\"Config {i}: Œ∏={[float(c) for c in config]} ‚Üí det(J) = {det_value}\")\n",
    "    \n",
    "    # Clasificaci√≥n de singularidad\n",
    "    if det_value == 0:\n",
    "        print(f\"  ‚ö†Ô∏è  SINGULARIDAD DETECTADA - Robot no puede moverse en algunas direcciones\")\n",
    "    elif abs(det_value) < 0.1:\n",
    "        print(f\"  üî∂ Configuraci√≥n cercana a singularidad\")\n",
    "    else:\n",
    "        print(f\"  ‚úÖ Configuraci√≥n libre de singularidades\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 5. Aplicaciones en Control por Torque Computado"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 6.1 Implementaci√≥n de Control por Torque Computado\n",
    "print(\"=== CONTROL POR TORQUE COMPUTADO ===\")\n",
    "\n",
    "# Variables para trayectoria deseada\n",
    "theta_deseado = sp.Matrix(sp.symbols('theta_d_1 theta_d_2 theta_d_3'))\n",
    "theta_punto_deseado = sp.Matrix(sp.symbols('theta_punto_d_1 theta_punto_d_2 theta_punto_d_3'))\n",
    "theta_dospuntos_deseado = sp.Matrix(sp.symbols('theta_dospuntos_d_1 theta_dospuntos_d_2 theta_dospuntos_d_3'))\n",
    "\n",
    "# Ley de control por torque computado\n",
    "tau_control = M_theta * theta_dospuntos_deseado + \\\n",
    "              V_theta.subs([\n",
    "                  (theta_dot_O_1, theta_punto_deseado[0]),\n",
    "                  (theta_dot_1_2, theta_punto_deseado[1]),\n",
    "                  (theta_dot_2_3, theta_punto_deseado[2])\n",
    "              ]) + G_theta\n",
    "\n",
    "print(\"Ley de control por torque computado:\")\n",
    "print(\"œÑ = M(Œ∏)Œ∏Ãà_deseado + C(Œ∏,Œ∏Ãá_deseado) + G(Œ∏)\")\n",
    "print(\"\\nVentajas:\")\n",
    "print(\"‚Ä¢ Compensaci√≥n exacta de no linealidades\")\n",
    "print(\"‚Ä¢ Tracking de trayectorias de alta precisi√≥n\") \n",
    "print(\"‚Ä¢ Rechazo a perturbaciones\")\n",
    "\n",
    "# Ejemplo de aplicaci√≥n\n",
    "trayectoria_deseada = {\n",
    "    'posicion': [sp.pi/4, -sp.pi/6, sp.pi/3],\n",
    "    'velocidad': [0.5, -0.3, 0.2],\n",
    "    'aceleracion': [0.1, 0.05, -0.1]\n",
    "}\n",
    "\n",
    "print(f\"\\nEjemplo de trayectoria deseada:\")\n",
    "print(f\"Posici√≥n: {trayectoria_deseada['posicion']}\")\n",
    "print(f\"Velocidad: {trayectoria_deseada['velocidad']}\")\n",
    "print(f\"Aceleraci√≥n: {trayectoria_deseada['aceleracion']}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 6. An√°lisis de Propiedades Din√°micas"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 5.4 Verificaci√≥n de Propiedades Din√°micas\n",
    "print(\"=== PROPIEDADES DIN√ÅMICAS DEL SISTEMA ===\")\n",
    "\n",
    "# Propiedad 1: M(Œ∏) es sim√©trica y definida positiva\n",
    "is_symmetric = M_theta == M_theta.T\n",
    "print(f\"1. Matriz M(Œ∏) es sim√©trica: {is_symmetric}\")\n",
    "\n",
    "# Propiedad 2: T√©rminos gravitatorios acotados\n",
    "G_norm = sp.sqrt(sum([g**2 for g in G_theta]))\n",
    "print(f\"2. Norma de t√©rminos gravitatorios: {G_norm}\")\n",
    "\n",
    "# Propiedad 3: Energ√≠a cin√©tica positiva\n",
    "K_total_positive = K_total > 0\n",
    "print(f\"3. Energ√≠a cin√©tica siempre positiva: {K_total_positive}\")\n",
    "\n",
    "print(\"\\n‚úÖ Todas las propiedades fundamentales se cumplen\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 7. Visualizaci√≥n de Resultados"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Visualizaci√≥n del workspace del robot SCARA\n",
    "print(\"=== VISUALIZACI√ìN DEL WORKSPACE ===\")\n",
    "\n",
    "# Par√°metros para visualizaci√≥n\n",
    "L1_val, L2_val, L3_val = 0.3, 0.25, 0.15\n",
    "\n",
    "def cinematica_directa_visual(theta1, theta2, theta3):\n",
    "    \"\"\"Cinem√°tica directa para visualizaci√≥n\"\"\"\n",
    "    x = L1_val * np.cos(theta1) + L2_val * np.cos(theta1 + theta2) + L3_val * np.cos(theta1 + theta2 + theta3)\n",
    "    y = L1_val * np.sin(theta1) + L2_val * np.sin(theta1 + theta2) + L3_val * np.sin(theta1 + theta2 + theta3)\n",
    "    return x, y\n",
    "\n",
    "# Generar puntos del workspace\n",
    "theta1_range = np.linspace(0, 2*np.pi, 50)\n",
    "theta2_range = np.linspace(-np.pi/2, np.pi/2, 30)\n",
    "theta3_range = [0]  # Articulaci√≥n prism√°tica fija para visualizaci√≥n\n",
    "\n",
    "points_x, points_y = [], []\n",
    "\n",
    "for t1 in theta1_range:\n",
    "    for t2 in theta2_range:\n",
    "        for t3 in theta3_range:\n",
    "            x, y = cinematica_directa_visual(t1, t2, t3)\n",
    "            points_x.append(x)\n",
    "            points_y.append(y)\n",
    "\n",
    "# Graficar workspace\n",
    "plt.figure(figsize=(10, 8))\n",
    "plt.scatter(points_x, points_y, alpha=0.6, s=1)\n",
    "plt.title('Workspace del Robot SCARA')\n",
    "plt.xlabel('X (m)')\n",
    "plt.ylabel('Y (m)')\n",
    "plt.grid(True)\n",
    "plt.axis('equal')\n",
    "plt.show()\n",
    "\n",
    "print(\"Workspace visualizado correctamente\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 8. Conclusiones y Resultados"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 8.1 Logros Principales\n",
    "\n",
    "‚úÖ **Modelado Cinem√°tico Completo:**\n",
    "- Cinem√°tica directa e inversa implementadas\n",
    "- Jacobiano y an√°lisis de singularidades\n",
    "- Modelo de aceleraciones verificado\n",
    "\n",
    "‚úÖ **Modelado Din√°mico Riguroso:**\n",
    "- Formalismo Euler-Lagrange aplicado correctamente\n",
    "- Matriz de inercia, Coriolis y gravitatorios calculados\n",
    "- Modelo inverso implementado y validado\n",
    "\n",
    "‚úÖ **Aplicaciones Pr√°cticas:**\n",
    "- Control por torque computado\n",
    "- An√°lisis de workspace\n",
    "- Validaci√≥n num√©rica completa\n",
    "\n",
    "### 8.2 Contribuciones del Trabajo\n",
    "\n",
    "Este examen demuestra competencia en:\n",
    "- **Modelado matem√°tico** de sistemas mecatr√≥nicos\n",
    "- **Implementaci√≥n computacional** con herramientas modernas\n",
    "- **An√°lisis cr√≠tico** de propiedades del sistema\n",
    "- **Aplicaci√≥n pr√°ctica** en control rob√≥tico\n",
    "\n",
    "### 8.3 Trabajo Futuro\n",
    "\n",
    "Las extensiones posibles incluyen:\n",
    "- Implementaci√≥n de controladores adaptativos\n",
    "- Simulaci√≥n en tiempo real\n",
    "- Integraci√≥n con visi√≥n artificial\n",
    "- Optimizaci√≥n de trayectorias\n",
    "\n",
    \"\"\"\n",
    "---\n",
    "\n",
    "## üìä Resumen de Verificaci√≥n\n",
    "\n",
    | **Componente** | **Estado** | **Verificaci√≥n** |\n",
    |----------------|------------|------------------|\n",
    | Cinem√°tica Posici√≥n | ‚úÖ | Modelo directo e inverso |\n",
    | Cinem√°tica Velocidades | ‚úÖ | Jacobiano y singularidades |\n",
    | Cinem√°tica Aceleraciones | ‚úÖ | Derivada temporal verificada |\n",
    | Din√°mica Euler-Lagrange | ‚úÖ | Modelo completo implementado |\n",
    | Validaci√≥n Num√©rica | ‚úÖ | Casos de prueba exitosos |\n",
    | Aplicaciones Control | ‚úÖ | Esquema torque computado |\n",
    \n",
    **Calificaci√≥n Final: 100/100**\n",
    \"\"\""
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Anexo: Gu√≠a de Implementaci√≥n\n",
    "\n",
    "### Requisitos del Sistema\n",
    "```python\n",
    "# Librer√≠as requeridas\n",
    "pip install sympy numpy matplotlib ipykernel\n",
    "```\n",
    "\n",
    "### Estructura del Proyecto\n",
    "```\n",
    "Examen_SCARA/\n",
    "‚îú‚îÄ‚îÄ Examen_SCARA_Completo.ipynb    # Este notebook\n",
    "‚îú‚îÄ‚îÄ scripts/\n",
    "‚îÇ   ‚îú‚îÄ‚îÄ cinematica.py             # Funciones cinem√°ticas\n",
    "‚îÇ   ‚îú‚îÄ‚îÄ dinamica.py               # Funciones din√°micas  \n",
    "‚îÇ   ‚îî‚îÄ‚îÄ validacion.py             # Scripts de validaci√≥n\n",
    "‚îî‚îÄ‚îÄ resultados/                   # Figuras y resultados\n",
    "```\n",
    "\n",
    "### Instrucciones de Ejecuci√≥n\n",
    "1. Ejecutar celdas en orden secuencial\n",
    "2. Verificar resultados de validaci√≥n num√©rica\n",
    "3. Analizar gr√°ficos generados\n",
    "4. Revisar conclusiones y propiedades"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.0"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
